<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog Template</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="w-screen bg-[url(img/bg.png)] bg-repeat flex flex-col items-center pt-2 pb-2">
    <div class="w-[1024px] p-3 flex flex-col items-center bg-gray-900/40">
        <div id="header" class="w-9/10 min-h-30 border-3 rounded-xl border-green-500">
            <div class="w-full flex flex-row justify-center">
                <p class="text-green-500 text-[2rem] font-bold">BLOG TEMPLATE</p>
            </div>
            <div class="w-full flex flex-row justify-center mt-3">
                <p class="text-green-500 text-[1.5rem]">Template for a geocities like blog post page</p>
            </div>
        </div>
        <div class="flex flex-row justify-between w-9/10 mt-6">
            <div class="w-[250px] flex flex-col items-center gap-1">
                <div class="w-full border-3 border-green-500 rounded-xl flex flex-col items-center gap-1 pt-3 pb-3">
                    <div class="w-9/10">
                        <img src="img/Perfil.png" alt="">
                    </div>
                    <p class="text-green-500 text-[1rem] w-9/10">@talkys.assis</p>
                    <p class="text-green-500">Bachelor of Computer Science</p>
                </div>
            </div>
            <div class="w-[600px] flex flex-col items-center gap-1">
                <div class="w-full border-3 border-green-500 rounded-xl flex flex-col items-start gap-2 p-3 backdrop-blur-xs">
                    <p class="text-gray-200 text-[1.7rem]">Why is Go so fast?</p>
                    <p class="text-gray-200">Go's threading model is so efficient primarily due to goroutines and the scheduler. Unlike traditional threads, which are managed by the operating system, goroutines are lightweight, user-space threads managed by the Go runtime. This design allows for a massive number of concurrent tasks without the overhead of OS-level context switching.</p>
                    <p class="text-gray-200 text-[1.2rem]">Goroutines vs. OS Threads</p>
                    <p class="text-gray-200">Traditional programming languages often use operating system (OS) threads for concurrency. An OS thread is a heavy process with a large memory footprint (typically 1-2 MB). Switching between these threads (context switching) is an expensive operation performed by the OS kernel. This overhead limits the number of concurrent threads a program can effectively use.</p>
                    <p class="text-gray-200">In contrast, a goroutine is extremely lightweight, starting with a stack of just a few kilobytes (typically 2-4 KB). This small size allows millions of goroutines to run on a single machine, far surpassing the capabilities of OS threads. Goroutines are also multiplexed onto a small number of OS threads, which is managed by the Go runtime scheduler. This means that many goroutines can run on just a few OS threads, minimizing kernel-level context switching and its associated costs.</p>
                    <p class="text-gray-200 text-[1.2rem]">The Go Scheduler</p>
                    <p class="text-gray-200">The Go scheduler is a key component of Go's concurrency model. It's a user-space scheduler, meaning it runs within the Go program itself, not in the OS kernel. Its main job is to efficiently manage and distribute goroutines across the available OS threads.</p>
                    <p class="text-gray-200">The scheduler uses a M:N model (many-to-many), where it maps M goroutines to N OS threads. It proactively decides when to switch goroutines, using cooperative scheduling and preemption, which further optimizes performance. When a goroutine makes a blocking system call (like reading a file or a network request), the scheduler detaches it from its OS thread and finds another runnable goroutine to execute. This ensures that the OS thread remains busy and productive, preventing it from being tied up by a single, blocking operation.</p>
                    <p class="text-gray-200">This efficient design allows Go to achieve high levels of concurrency with minimal resource consumption, making it ideal for building scalable and high-performance network services.</p>
                </div>
            </div>
        </div>
    </div>
    
</body>
</html>